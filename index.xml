<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>PowerShell by Example on PowerShell By Example</title><link>https://powershellbyexample.dev/</link><description>Recent content in PowerShell by Example on PowerShell By Example</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Mon, 11 Apr 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://powershellbyexample.dev/index.xml" rel="self" type="application/rss+xml"/><item><title>Hello World</title><link>https://powershellbyexample.dev/post/hello-world/</link><pubDate>Tue, 22 Feb 2022 00:00:00 +0000</pubDate><guid>https://powershellbyexample.dev/post/hello-world/</guid><description>As with every first program we write, we will print the classic &amp;ldquo;hello world&amp;rdquo; message. Hereâ€™s the full source code.
Write-Host &amp;#39;Hello, World!&amp;#39; &amp;#39;Hello, World!&amp;#39; | Write-Host Result:
Hello, World! Hello, World! There is another method to print the output or the strings to screen and that is is Write-Output.
Write-Output &amp;#39;Hello, World!&amp;#39; &amp;#39;Hello, World!&amp;#39; | Write-Output This will print the exact same thing as the previous snippet.
Result:
Hello, World!</description></item><item><title>Variables</title><link>https://powershellbyexample.dev/post/variables/</link><pubDate>Tue, 22 Feb 2022 00:00:00 +0000</pubDate><guid>https://powershellbyexample.dev/post/variables/</guid><description>In PowerShell we can store all types of values in PowerShell variables. It&amp;rsquo;s possible to store the results of commands, and store elements that are used in commands and expressions, such as names, paths, settings, and values.
PowerShell variables, unlike other languages are not case-sensitive, and can include spaces and special characters. Variable names with special characters and spaces are difficult to use and should be avoided. For more information, see Variable names that include special characters.</description></item><item><title>Read-Only Variables</title><link>https://powershellbyexample.dev/post/read-only-variables/</link><pubDate>Tue, 22 Feb 2022 00:00:00 +0000</pubDate><guid>https://powershellbyexample.dev/post/read-only-variables/</guid><description>PowerShell supports constants and read-only variables.
Read-only variables are variables that cannot be changed, in a regular way.
You create a read-only variable with the New-Variable command with the parameter -Option ReadOnly.
New-Variable -Name myVar -Value 1337 -Option ReadOnly $myVar Let&amp;rsquo;s try and change it
$myVar = 31337 Cannot overwrite variable myVar because it is read-only or constant. At line:1 char:1 + $myVar = 31337 + ~~~~~~~~~~~~~~ + CategoryInfo : WriteError: (myVar:String) [], SessionStateUnauthorizedAccessException + FullyQualifiedErrorId : VariableNotWritable To change the variable we need to use the -Force parameter:</description></item><item><title>Constants</title><link>https://powershellbyexample.dev/post/constants/</link><pubDate>Tue, 22 Feb 2022 00:00:00 +0000</pubDate><guid>https://powershellbyexample.dev/post/constants/</guid><description>PowerShell supports constants and read-only variables.
Constants are variables that cannot be changed whatever you try.
You create a constant variable with the New-Variable command with the parameter -Option Constant.
New-Variable -Name myConst -Value &amp;#34;This CANNOT be changed&amp;#34; -Option Constant $myConst We can&amp;rsquo;t change te value even with the -Force parameter
New-Variable -Name myConst -Value &amp;#34;I&amp;#39;m going to change it&amp;#34; -Option Constant -Force New-Variable : Cannot overwrite variable myConst because it is read-only or constant.</description></item><item><title>For</title><link>https://powershellbyexample.dev/post/for/</link><pubDate>Tue, 22 Feb 2022 00:00:00 +0000</pubDate><guid>https://powershellbyexample.dev/post/for/</guid><description>Classic for loop
for ($i = 1; $i -le 5; $i++){ Write-Host $i } Result:
1 2 3 4 5 We can also use text in our for loop conditions
for ($i = &amp;#39;&amp;#39; ; $i.length -le 20; $i += &amp;#39;=&amp;#39;){ Write-Host $i } Result:
= == === ==== ===== ====== ======= ======== ========= ========== =========== ============ ... ... ====================</description></item><item><title>Foreach</title><link>https://powershellbyexample.dev/post/foreach/</link><pubDate>Tue, 22 Feb 2022 00:00:00 +0000</pubDate><guid>https://powershellbyexample.dev/post/foreach/</guid><description>Foreach is a loop that iterates over a collection.
$list = @(&amp;#39;a&amp;#39;, &amp;#39;b&amp;#39;, &amp;#39;c&amp;#39;, &amp;#39;d&amp;#39;); foreach($item in $list){ Write-Host $item } Result:
a b c d The equivalent of the above is:
$list = @(&amp;#39;a&amp;#39;, &amp;#39;b&amp;#39;, &amp;#39;c&amp;#39;, &amp;#39;d&amp;#39;); $list | ForEach-Object { Write-Host $_ } Result:
a b c d The ForEach-Object command has more options than the basic foreach loop. For more info about the ForEach-Object command run the Get-Help command.</description></item><item><title>If/Else</title><link>https://powershellbyexample.dev/post/if-else/</link><pubDate>Wed, 23 Feb 2022 00:00:00 +0000</pubDate><guid>https://powershellbyexample.dev/post/if-else/</guid><description>Using if and else statements in PowerShell is pretty straightforward.
You can have an if statement without an else statement.
$value = 5 if ($value -gt 1) { Write-Host &amp;#34;value is greater than 1&amp;#34; } Result:
value is greater than 1 You can have an if statement with a single else statement, or an if statement with an else if statement.
$value = 5 if ($value -gt 10) { Write-Host &amp;#34;value is greater than 10&amp;#34; } else { Write-Host &amp;#34;value is $value&amp;#34; } if ($value -gt 10) { Write-Host &amp;#34;value is greater than 10&amp;#34; } elseif ($value -lt 10) { Write-Host &amp;#34;value is less than 10&amp;#34; } else { Write-Host &amp;#34;value is 10&amp;#34; } Result:</description></item><item><title>Switch</title><link>https://powershellbyexample.dev/post/switch/</link><pubDate>Wed, 23 Feb 2022 00:00:00 +0000</pubDate><guid>https://powershellbyexample.dev/post/switch/</guid><description>Switch statements are a way to execute different code based on different conditions. This approach can be more efficient than using multiple if/elseif statements
$month = 3 if ($month -eq 1) { Write-Host &amp;#34;January&amp;#34; } elseif ($month -eq 2) { Write-Host &amp;#34;February&amp;#34; } elseif ($month -eq 3) { Write-Host &amp;#34;March&amp;#34; } elseif ($month -eq 4) { Write-Host &amp;#34;April&amp;#34; } elseif ($month -eq 5) { Write-Host &amp;#34;May&amp;#34; } elseif ($month -eq 6) { Write-Host &amp;#34;June&amp;#34; } elseif ($month -eq 7) { Write-Host &amp;#34;July&amp;#34; } elseif ($month -eq 8) { Write-Host &amp;#34;August&amp;#34; } elseif ($month -eq 9) { Write-Host &amp;#34;September&amp;#34; } elseif ($month -eq 10) { Write-Host &amp;#34;October&amp;#34; } elseif ($month -eq 11) { Write-Host &amp;#34;November&amp;#34; } elseif ($month -eq 12) { Write-Host &amp;#34;December&amp;#34; } else { Write-Host &amp;#34;Invalid month&amp;#34; } # Instead we can write the above as switch ($month) { 1 { Write-Host &amp;#34;January&amp;#34; } 2 { Write-Host &amp;#34;February&amp;#34; } 3 { Write-Host &amp;#34;March&amp;#34; } 4 { Write-Host &amp;#34;April&amp;#34; } 5 { Write-Host &amp;#34;May&amp;#34; } 6 { Write-Host &amp;#34;June&amp;#34; } 7 { Write-Host &amp;#34;July&amp;#34; } 8 { Write-Host &amp;#34;August&amp;#34; } 9 { Write-Host &amp;#34;September&amp;#34; } 10 { Write-Host &amp;#34;October&amp;#34; } 11 { Write-Host &amp;#34;November&amp;#34; } 12 { Write-Host &amp;#34;December&amp;#34; } default { Write-Host &amp;#34;Invalid month&amp;#34; } } Result:</description></item><item><title>Arrays</title><link>https://powershellbyexample.dev/post/arrays/</link><pubDate>Wed, 23 Feb 2022 00:00:00 +0000</pubDate><guid>https://powershellbyexample.dev/post/arrays/</guid><description>An array is a data structure that is designed to store a collection of items. The items can be the same type or different types.
Creating arrays Define an array using the @()
$values = @(&amp;#34;One&amp;#34;, &amp;#34;Two&amp;#34;, &amp;#34;Three&amp;#34;, &amp;#34;Four&amp;#34;, &amp;#34;Five&amp;#34;) $values $values.GetType() Result:
One Two Three Four Five IsPublic IsSerial Name BaseType -------- -------- ---- -------- True True Object[] System.Array Define an array by setting with comma separated values
$values = &amp;#34;Six&amp;#34;, &amp;#34;Seven&amp;#34;, &amp;#34;Eight&amp;#34;, &amp;#34;Nine&amp;#34;, &amp;#34;10&amp;#34; $values Result:</description></item><item><title>Multidimensional Arrays</title><link>https://powershellbyexample.dev/post/multidimensional-arrays/</link><pubDate>Wed, 23 Feb 2022 00:00:00 +0000</pubDate><guid>https://powershellbyexample.dev/post/multidimensional-arrays/</guid><description>There are two types of multidimensional arrays, jagged and true multidimensional arrays.
Jagged arrays Jagged arrays are the arrays you will probably use the most. These types of arrays are very cost effective because the dimensions can be different in size.
$array = @(1, 2, (1, 2, 3), 3, 4, (10, 11, 12), 5) $array[0] $array[1] $array[2] $array[2][0] $array[2][1] $array[5] Result:
1 2 1 2 3 1 2 10 11 12 True multidimensional arrays With true multidimensional arrays can be compared to a matrix.</description></item><item><title>Hashtables</title><link>https://powershellbyexample.dev/post/hashtables/</link><pubDate>Wed, 23 Feb 2022 00:00:00 +0000</pubDate><guid>https://powershellbyexample.dev/post/hashtables/</guid><description>In the arrays example we saw how to create arrays. In this example we will see how to create hashtables.
A hashtable is a data structure, similar like an array, but with a hashtable each value is stored with a key. You can compare it to a key/value store database structure.
To declare a hastable we use the @{} syntax:
$employees = @{} This is different from the arrays where the @() is used.</description></item><item><title>Functions</title><link>https://powershellbyexample.dev/post/functions/</link><pubDate>Tue, 22 Feb 2022 00:00:00 +0000</pubDate><guid>https://powershellbyexample.dev/post/functions/</guid><description>Functions are not required in PowerShell, but when your code becomes repetitive you should consider using functions. Also when creating PowerShell modules you should really consider putting code into functions to make your code more readable.
To create a function we use the function keyword:
function writeHelloWorld() { Write-Host &amp;#34;Hello World!&amp;#34; } writeHelloWorld Result:
Hello World! Obviously this function is not very useful, but it is a good example how easy it is to create a function.</description></item><item><title>Scopes</title><link>https://powershellbyexample.dev/post/variable-scopes/</link><pubDate>Tue, 22 Feb 2022 00:00:00 +0000</pubDate><guid>https://powershellbyexample.dev/post/variable-scopes/</guid><description>When you create a variable, alias or a function in PowerShell, it is only available in the current scope where it was created. For example, when you create a variable in a function, it is only available in the function. When you create a variable in a script, it is available in the script and all functions in the script.
There is a way to make these items available outside it&amp;rsquo;s current scope.</description></item><item><title>Strings</title><link>https://powershellbyexample.dev/post/strings/</link><pubDate>Tue, 01 Mar 2022 00:00:00 +0000</pubDate><guid>https://powershellbyexample.dev/post/strings/</guid><description>Defining strings There are various ways you define a string in PowerShell
$var = &amp;#34;Hello World!&amp;#34; &amp;#34;Lorem ipsum dolor sit amet...&amp;#34; $value1 = &amp;#34;Ut enim ad minim veniam... $var&amp;#34; $value2 = &amp;#39;Duis aute irure dolor in... $var&amp;#39; [string]$value3 = &amp;#34;Excepteur sint occaecat cupidatat non proident...&amp;#34; $value1, $value2, $value3 write-host $value1, $value2, $value3 write-host $value1 $value2 $value3 Result:
Lorem ipsum dolor sit amet... Ut enim ad minim veniam... Hello World!</description></item><item><title>Error Actions</title><link>https://powershellbyexample.dev/post/error-actions/</link><pubDate>Wed, 09 Mar 2022 00:00:00 +0000</pubDate><guid>https://powershellbyexample.dev/post/error-actions/</guid><description>In normal circumstances, because we want PowerShell to work even though sometimes we have errors. That is the reason why PowerShell errors in general are what we call non-terminating errors.
Clear-Host $items = @() # Generate more items $items += for ($i = 0; $i -le 3; $i++) { &amp;#34;$($env:TEMP)\$(Get-Process -Id $pid)-$($i).txt&amp;#34; } # Let&amp;#39;s generate some errors $items | ForEach-Object { Get-Item -Path $_ } Result:</description></item><item><title>Error Handling</title><link>https://powershellbyexample.dev/post/error-handling/</link><pubDate>Wed, 09 Mar 2022 00:00:00 +0000</pubDate><guid>https://powershellbyexample.dev/post/error-handling/</guid><description>The try/catch blocks in PowerShell are used to handle terminating error. With the try/catch block you also have a finally keyword that will be executed even when an error is found.
General The example below is a standard way to do a try/catch block
try { # This will generate an error 1/0 Write-Host &amp;#34;This is executed after the error&amp;#34; } catch { # Catch all errors Write-Host &amp;#34;Oh oh!</description></item><item><title>Reading Files</title><link>https://powershellbyexample.dev/post/reading-files/</link><pubDate>Wed, 09 Mar 2022 00:00:00 +0000</pubDate><guid>https://powershellbyexample.dev/post/reading-files/</guid><description>To demonstrate reading files we need sample files first.
# Let&amp;#39;s download a sample file just for the example $url = &amp;#34;https://gist.githubusercontent.com/sanderstad/7b9593f7f30abb9f17f9026c74ed9c68/raw/d4406c4cbbc427e15fc9d6d92f8bcf3c72a1e70a/samplefile1.txt&amp;#34; $filePath = Join-Path -Path $env:temp -ChildPath &amp;#34;samplefile1.txt&amp;#34; Invoke-WebRequest -Uri $url -OutFile $filePath $url = &amp;#34;https://gist.githubusercontent.com/sanderstad/f59996889fc3ec794d325ad2162648f8/raw/5353480009bd714f9764a093b52f0fabff1078fd/samplefile2.csv&amp;#34; $filePath = Join-Path -Path $env:temp -ChildPath &amp;#34;samplefile2.txt&amp;#34; Invoke-WebRequest -Uri $url -OutFile $filePath Get-Content The easiest way to read files in PowerShell is by using the the Get-Content command.
# Get the content Get-Content -Path (Join-Path -Path $env:temp -ChildPath &amp;#34;samplefile1.</description></item><item><title>Writing Files</title><link>https://powershellbyexample.dev/post/writing-files/</link><pubDate>Thu, 10 Mar 2022 00:00:00 +0000</pubDate><guid>https://powershellbyexample.dev/post/writing-files/</guid><description>There are several methods to write data to files
Add-Content To add content to a file run the following script:
Add-Content -Path (Join-Path -Path $env:TEMP -ChildPath &amp;#34;test1.txt&amp;#34;) -Value &amp;#34;This is just a test&amp;#34; Add-Content -Path (Join-Path -Path $env:TEMP -ChildPath &amp;#34;test1.txt&amp;#34;) -Value &amp;#34;This is just another test&amp;#34; Get-Content (Join-Path -Path $env:TEMP -ChildPath &amp;#34;test1.txt&amp;#34;) Result:
This is just a test This is just another test In this example you see that the command Add-Content automatically creates the file if it doesn&amp;rsquo;t exist.</description></item><item><title>Time and Date</title><link>https://powershellbyexample.dev/post/time-and-date/</link><pubDate>Mon, 14 Mar 2022 00:00:00 +0000</pubDate><guid>https://powershellbyexample.dev/post/time-and-date/</guid><description>In many operations within PowerShell we need time and date information. When date and time values are being returned that is done with the [datetime] data type. The format that&amp;rsquo;s being returned depends on the cultural settings of the computer.
General To get the current date and time, use the Get-Date command.
Get-Date Result:
Monday, March 14, 2022 4:40:48 PM Date and time parts To get specific values from the command we can use the properties in the [datetime] type.</description></item><item><title>Sorting</title><link>https://powershellbyexample.dev/post/sorting/</link><pubDate>Tue, 05 Apr 2022 00:00:00 +0000</pubDate><guid>https://powershellbyexample.dev/post/sorting/</guid><description>Sorting values is important in any programming language. To do this in PowerShell you can use the Sort-Object command. By default the sort is done in ascending order and case insensitive.
Here are some examples how to sort data in PowerShell.
Sort by value $names = @(&amp;#34;Muffin&amp;#34;,&amp;#34;Romeo&amp;#34;,&amp;#34;Noodle&amp;#34;,&amp;#34;Zoe&amp;#34;,&amp;#34;Jack&amp;#34;,&amp;#34;Luna&amp;#34;,&amp;#34;Gracie&amp;#34;,&amp;#34;mittens&amp;#34;,&amp;#34;Phoebe&amp;#34;,&amp;#34;Peanut&amp;#34;,&amp;#34;Harley&amp;#34;,&amp;#34;Jake&amp;#34;) $names | Sort-Object The result:
Gracie Harley Jack Jake Luna mittens Muffin Noodle Peanut Phoebe Romeo Zoe Sort by descending order By default any data is sorted in ascending order.</description></item><item><title>Classes</title><link>https://powershellbyexample.dev/post/classes/</link><pubDate>Mon, 11 Apr 2022 00:00:00 +0000</pubDate><guid>https://powershellbyexample.dev/post/classes/</guid><description>Since PowerShell 5 you are able to create your own classes in PowerShell.
Although classes in other programming languages are a big advantage and sometimes even required, they are not required in PowerShell.
In some cases you may want to use classes in PowerShell to create objects that can be used in PowerShell. One of those examples is when you use DSC (Desired State Configuration). Most of the time you will not need to use classes in PowerShell, and you will be fine using custom objects in your commands instead.</description></item></channel></rss>